<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title>Hoh reference encoder/decoder</title>
		<style>
.canvasContainer{
	display: inline-block;
	padding: 5px;
	margin: 5px;
	border: solid;
	border-width: 1px;
	border-radius: 3px;
	max-width: 40%;
}
canvas{
	max-width: 100%;
}
body{
	background: rgb(200,200,200);
	padding: 20px;
}
		</style>
	</head>
	<body>
		<div class="canvasContainer">
			<h2>Original</h2>
			<canvas id="preview" width="0" height="0"></canvas>
		</div>
		<div class="canvasContainer">
			<h2>Decoded</h2>
			<canvas id="render" width="0" height="0"></canvas>
		</div>
		<hr>
		<h3>Decode</h3>
		<input type="file" id="hohInput"><br>
		<hr>
		<h3>Encode</h3>
		<input type="file" id="imageInput"><br>
		<h4>Parameters:</h4>
		Quantizer: <input id="quantizer" value="0" type="number" min="0" step="0.001"> 0 = lossless. Higher number = more lossy. Useful values &lt; 0.1<br>
		Max block size: <input id="maxBlockSize" value="128" type="number" min="0" step="1"> 0 = no limit. Large blocks are mostly useless, so setting a limit improves encoding speed greatly<br>
		Grouping constant: <input id="groupingConstant" value="8" type="number" min="0" step="1" max="255"> 8 is good for basically everything. A few % can sometimes be saved by tweaking it<br>
		Brute-force gradients: <input id="bruteForce" type="checkbox" checked><br>
		<button id="encodeButton">encode again</button>
		<h4>Stats:</h4>
		<p id="encodeStats"></p>
		<script src="hoh.js"></script>
		<script>
let saveByteArray = (function(){
	let a = document.createElement("a");
	document.body.appendChild(a);
	a.style = "display: none";
	return function(data,name){
		let blob = new Blob(data, {type: "octet/stream"});
		let url = window.URL.createObjectURL(blob);
		a.href = url;
		a.download = name;
		a.click();
		window.URL.revokeObjectURL(url)
	}
}())

function readFileAsArrayBuffer(file, success, error) {
	let fr = new FileReader();
	fr.addEventListener('error', error, false);
	if(fr.readAsBinaryString){
		fr.addEventListener('load', function(){
			var string = this.resultString != null ? this.resultString : this.result;
			var result = new Uint8Array(string.length);
			for(var i = 0; i < string.length; i++){
				result[i] = string.charCodeAt(i)
			}
			success(result.buffer)
		}, false);
		return fr.readAsBinaryString(file);
	}
	else {
		fr.addEventListener('load', function(){
			success(this.result)
		}, false);
		return fr.readAsArrayBuffer(file)
	}
}

function drawToCanvas(imageData){
	let canvas = document.getElementById("render");
	canvas.width = imageData.length;
	canvas.height = imageData[0].length || 0;
	let ctx = canvas.getContext("2d");
	imageData.forEach((row,i) => {
		row.forEach((cel,j) => {
			ctx.fillStyle = "rgb(" + cel + "," + cel + "," + cel +")";
			ctx.fillRect(i,j,1,1)
		})
	})
}

function hohStatsHandler(data){
	document.getElementById("encodeStats").innerText = `
compression: ${Math.round((1 - (data.size / (data.width * data.height)))*10000)/100 + "%"}
time: ${data.time + "ms"}
`
}

const inputElement = document.getElementById("hohInput");

let html_decode = function(){
	const fileList = inputElement.files;
	readFileAsArrayBuffer(fileList[0], function(data){
		let decodedData = decodeHoh(new Uint8Array(data));
		if(decodedData){
			drawToCanvas(decodedData)
		}
	},function(e){
		console.error(e);
	})
}
inputElement.addEventListener("change",html_decode,false);

const inputElementEncode = document.getElementById("imageInput");
const buttonElementEncode = document.getElementById("encodeButton");

let html_encode = function(){
	if(inputElementEncode.files && inputElementEncode.files[0]){
		let fileName = inputElementEncode.files[0].name;
		let FR = new FileReader();
		FR.onload = function(e){
			let img = new Image();
			img.addEventListener("load", function(){
				let canvas = document.getElementById("preview");
				canvas.height = img.height;
				canvas.width = img.width;
				let ctx = canvas.getContext("2d");
				ctx.drawImage(img, 0, 0);
				let contextData = ctx.getImageData(0,0,img.width,img.height).data;
				let imageData = [];
				for(let i=0;i<img.width;i++){
					let col = [];
					for(let j=0;j<img.height;j++){
						col.push(Math.round(
							contextData[i * 4 + j * img.width * 4] * 0.2989
							+ contextData[i * 4 + j * img.width * 4 + 1] * 0.5870
							+ contextData[i * 4 + j * img.width * 4 + 2] * 0.1140
						))
					};
					imageData.push(col)
				}
				saveByteArray([encodeHoh(imageData,{
					quantizer: parseFloat(document.getElementById("quantizer").value) || 0,
					forceGradients: document.getElementById("bruteForce").checked,
					lossySmallGradients: true,
					forceGradientsExtra: true,
					groupingConstant: parseInt(document.getElementById("groupingConstant").value) || 0,
					maxBlockSize: parseInt(document.getElementById("maxBlockSize").value) || 0
				})], fileName + ".hoh");
			});
			img.src = e.target.result;
		};       
		FR.readAsDataURL(inputElementEncode.files[0]);
	}
}
inputElementEncode.addEventListener("change",html_encode,false);
buttonElementEncode.addEventListener("click",html_encode,false);

		</script>
	</body>
</html>
