<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title>Hoh reference encoder/decoder</title>
		<style>
.canvasContainer{
	display: inline-block;
	padding: 5px;
	margin: 5px;
	border: solid;
	border-width: 1px;
	border-radius: 3px;
	max-width: 40%;
}
canvas{
	max-width: 100%;
	max-height: 600px;
}
body{
	background: rgb(200,200,200);
	padding: 20px;
}
		</style>
	</head>
	<body>
		<div class="canvasContainer">
			<h2>Original</h2>
			<canvas id="preview" width="0" height="0"></canvas>
		</div>
		<div class="canvasContainer">
			<h2>Decoded</h2>
			<canvas id="render" width="0" height="0"></canvas>
		</div>
		<hr>
		<h3>Decode</h3>
		<input type="file" id="hohInput"><br>
		<hr>
		<h3>Encode</h3>
		<input type="file" id="imageInput"><br>
		<h4>Parameters:</h4>
		Quantizer: <input id="quantizer" value="0" type="number" min="0" step="0.001"> 0 = lossless. Higher number = more lossy. Useful values &lt; 0.2<br>
		Colour Quantizer: <input id="colourQuantizer" value="0" type="number" min="0" step="0.001"> The eye is less sensitive to colour, so make this number higher<br>
		Max block size: <input id="maxBlockSize" value="64" type="number" min="0" step="1"> 0 = no limit. Large blocks are mostly useless, so setting a limit improves encoding speed greatly<br>
		Brute-force gradients: <input id="bruteForce" type="checkbox" checked><br>
		<button id="encodeButton">encode again</button>
		<h4>Stats:</h4>
		<p id="encodeStats"></p>
		<script src="hoh.js"></script>
		<script>
let saveByteArray = (function(){
	let a = document.createElement("a");
	document.body.appendChild(a);
	a.style = "display: none";
	return function(data,name){
		let blob = new Blob(data, {type: "octet/stream"});
		let url = window.URL.createObjectURL(blob);
		a.href = url;
		a.download = name;
		a.click();
		window.URL.revokeObjectURL(url)
	}
}())

function readFileAsArrayBuffer(file, success, error) {
	let fr = new FileReader();
	fr.addEventListener('error', error, false);
	if(fr.readAsBinaryString){
		fr.addEventListener('load', function(){
			var string = this.resultString != null ? this.resultString : this.result;
			var result = new Uint8Array(string.length);
			for(var i = 0; i < string.length; i++){
				result[i] = string.charCodeAt(i)
			}
			success(result.buffer)
		}, false);
		return fr.readAsBinaryString(file);
	}
	else {
		fr.addEventListener('load', function(){
			success(this.result)
		}, false);
		return fr.readAsArrayBuffer(file)
	}
}

function drawToCanvas(imageData){
	let canvas = document.getElementById("render");
	canvas.width = imageData.luma.length;
	canvas.height = imageData.luma[0].length || 0;
	let ctx = canvas.getContext("2d");
	if(imageData.Cb.length === 0){
		imageData.luma.forEach((row,i) => {
			row.forEach((cel,j) => {
				ctx.fillStyle = "rgb(" + cel + "," + cel + "," + cel +")";
				ctx.fillRect(i,j,1,1)
			})
		})
	}
	else{
		imageData.luma.forEach((col,i) => {
			col.forEach((cel,j) => {
				ctx.fillStyle = "rgb(" + Math.round(cel + 1.402 * (imageData.Cr[i][j] - 128)) + "," + Math.round(cel - 0.344136 * (imageData.Cb[i][j] - 128) - 0.714136 * (imageData.Cr[i][j] - 128)) + "," + Math.round(cel + 1.772 * (imageData.Cb[i][j] - 128)) +")";
				ctx.fillRect(i,j,1,1)
			})
		})
	}
}

function hohStatsHandler(data){
	document.getElementById("encodeStats").innerText = `
compression: ${Math.round((1 - (data.size / (data.width * data.height * 3)))*10000)/100 + "%"}
time: ${data.time + "ms"}
blocks used:
- ${data.whole} | solid colour
- ${data.vertical} | vertical gradients
- ${data.horizontal} | horizontal gradients
- ${data.diagonal} | diagonal gradients
- ${data.solid_diagonal} | solid diagonals
- ${data.small_gradients} | 2x2 lossless splits
- ${data.small_diagonals} | 2x2 lossless diagonals
- ${data.small_solid_diagonals} | 2x2 lossless solid diagonals
- ${data.lossy_small_gradients} | 2x2 lossy splits
- ${data.lossy_small_diagonals} | 2x2 lossy diagonals
- ${data.lossy_small_solid_diagonals} | 2x2 lossy solid diagonals
- ${data.single} | single pixels

huffman tables: ${data.huffman_tables} bytes

size: ${data.size} bytes
- header: 8 bytes
- luma: ${data.luma} bytes
- chroma: ${Math.max(data.chroma,0)} bytes
`
}

const inputElement = document.getElementById("hohInput");

let html_decode = function(){
	const fileList = inputElement.files;
	readFileAsArrayBuffer(fileList[0], function(data){
		let decodedData = decodeHoh(new Uint8Array(data));
		if(decodedData){
			drawToCanvas(decodedData)
		}
	},function(e){
		console.error(e);
	})
}
inputElement.addEventListener("change",html_decode,false);

const inputElementEncode = document.getElementById("imageInput");
const buttonElementEncode = document.getElementById("encodeButton");

let html_encode = function(){
	if(inputElementEncode.files && inputElementEncode.files[0]){
		let fileName = inputElementEncode.files[0].name;
		let FR = new FileReader();
		FR.onload = function(e){
			let img = new Image();
			img.addEventListener("load", function(){
				let canvas = document.getElementById("preview");
				canvas.height = img.height;
				canvas.width = img.width;
				let ctx = canvas.getContext("2d");
				ctx.drawImage(img, 0, 0);
				let contextData = ctx.getImageData(0,0,img.width,img.height).data;
				let imageData = [];
				for(let i=0;i<img.width;i++){
					let col = [];
					for(let j=0;j<img.height;j++){
						col.push(Math.round(
							contextData[i * 4 + j * img.width * 4] * 0.2989
							+ contextData[i * 4 + j * img.width * 4 + 1] * 0.5870
							+ contextData[i * 4 + j * img.width * 4 + 2] * 0.1140
						))
					};
					imageData.push(col)
				}
				let CBdata = [];
				for(let i=0;i<img.width;i++){
					let col = [];
					for(let j=0;j<img.height;j++){
						col.push(Math.round(
							128 
							- contextData[i * 4 + j * img.width * 4] * 0.168736
							- contextData[i * 4 + j * img.width * 4 + 1] * 0.331264
							+ contextData[i * 4 + j * img.width * 4 + 2] * 0.5
						))
					};
					CBdata.push(col)
				}
				let CRdata = [];
				for(let i=0;i<img.width;i++){
					let col = [];
					for(let j=0;j<img.height;j++){
						col.push(Math.round(
							128 
							+ contextData[i * 4 + j * img.width * 4] * 0.5
							- contextData[i * 4 + j * img.width * 4 + 1] * 0.418688
							- contextData[i * 4 + j * img.width * 4 + 2] * 0.081312
						))
					};
					CRdata.push(col)
				}
				saveByteArray([encodeHoh(imageData,{
					quantizer: (parseFloat(document.getElementById("quantizer").value) || 0)/10,
					forceGradients: document.getElementById("bruteForce").checked,
					lossySmallGradients: true,
					forceGradientsExtra: true,
					subSampling: (parseFloat(document.getElementById("colourQuantizer").value) || 0)/10,
					maxBlockSize: parseInt(document.getElementById("maxBlockSize").value) || 0,
					edgeWeight: 2,
				},CBdata,CRdata)], fileName + ".hoh");
			});
			img.src = e.target.result;
		};       
		FR.readAsDataURL(inputElementEncode.files[0]);
	}
}
inputElementEncode.addEventListener("change",html_encode,false);
buttonElementEncode.addEventListener("click",html_encode,false);

		</script>
	</body>
</html>
