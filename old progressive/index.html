<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title>Hoh reference encoder/decoder</title>
		<style>
.canvasContainer{
	display: inline-block;
	padding: 5px;
	margin: 5px;
	border: solid;
	border-width: 1px;
	border-radius: 3px;
	max-width: 40%;
}
canvas{
	max-width: 100%;
	max-height: 600px;
}
body{
	background: rgb(200,200,200);
	padding: 20px;
}
		</style>
	</head>
	<body>
		<div class="canvasContainer">
			<h2>Original</h2>
			<canvas id="preview" width="0" height="0"></canvas>
		</div>
		<div class="canvasContainer">
			<h2>Decoded</h2>
			<canvas id="render" width="0" height="0"></canvas>
		</div>
		<hr>
		<h3>Decode</h3>
		<input type="file" id="hohInput"><br>
		<hr>
		<h3>Encode</h3>
		<input type="file" id="imageInput"><br>
		<h4>Parameters:</h4>
		Quantizer: <input id="quantizer" value="0" type="number" min="0" step="0.001"> 0 = lossless. Higher number = more lossy. Useful values &lt; 0.2<br>
		Colour Quantizer: <input id="colourQuantizer" value="0" type="number" min="0" step="0.001"> The eye is less sensitive to colour, so make this number higher<br>
		Max block size: <input id="maxBlockSize" value="64" type="number" min="0" step="1"> 0 = no limit. Large blocks are mostly useless, so setting a limit improves encoding speed greatly<br>
		Brute-force block colours: <input id="bruteForce" type="checkbox"><br>
		Use DCT blocks: <input id="useDCT" type="checkbox"><br>
		<button id="encodeButton">encode again</button>
		<h4>Stats:</h4>
		<pre id="encodeStats"></pre>
		<script src="hoh.js"></script>
		<script>
let saveByteArray = (function(){
	let a = document.createElement("a");
	document.body.appendChild(a);
	a.style = "display: none";
	return function(data,name){
		let blob = new Blob(data, {type: "octet/stream"});
		let url = window.URL.createObjectURL(blob);
		a.href = url;
		a.download = name;
		a.click();
		window.URL.revokeObjectURL(url)
	}
}())

function readFileAsArrayBuffer(file, success, error) {
	let fr = new FileReader();
	fr.addEventListener('error', error, false);
	if(fr.readAsBinaryString){
		fr.addEventListener('load', function(){
			var string = this.resultString != null ? this.resultString : this.result;
			var result = new Uint8Array(string.length);
			for(var i = 0; i < string.length; i++){
				result[i] = string.charCodeAt(i)
			}
			success(result.buffer)
		}, false);
		return fr.readAsBinaryString(file);
	}
	else {
		fr.addEventListener('load', function(){
			success(this.result)
		}, false);
		return fr.readAsArrayBuffer(file)
	}
}

function drawToCanvas(imageData){
	let canvas = document.getElementById("render");
	canvas.width = imageData.luma.length;
	canvas.height = imageData.luma[0].length || 0;
	let ctx = canvas.getContext("2d");
	if(imageData.Cb.length === 0){
		imageData.luma.forEach((row,i) => {
			row.forEach((cel,j) => {
				ctx.fillStyle = "rgb(" + cel + "," + cel + "," + cel +")";
				ctx.fillRect(i,j,1,1)
			})
		})
	}
	else{
		let showFlat = [];
		for(let i=0;i<imageData.luma[0].length;i++){
			for(let j=0;j<imageData.luma.length;j++){
				showFlat.push(
					Math.round(imageData.luma[j][i] + imageData.Cb[j][i] - imageData.Cr[j][i]),
					Math.round(imageData.luma[j][i] + imageData.Cr[j][i] - 127.5),
					Math.round(imageData.luma[j][i] - imageData.Cb[j][i] - imageData.Cr[j][i] + 255),
					255
				)
			}
		}
		let image = new ImageData(new Uint8ClampedArray(showFlat),imageData.luma.length);
		ctx.putImageData(image,0,0);
	}
}

function hohStatsHandler(data){
	document.getElementById("encodeStats").innerText = `
compression: ${Math.round((1 - (data.size / (data.width * data.height * 3)))*10000)/100 + "%"}
time: ${data.time + "ms"}

huffman tables: ${data.huffman_tables} bytes

size: ${data.size} bytes
- header: 8 bytes
- luma: ${data.luma} bytes
- chroma: ${Math.max(data.chroma,0)} bytes

luma macroblocks: ${Object.keys(data.blockUsage[0].large).reduce((acc,val) => acc + data.blockUsage[0].large[val],0)}
${Object.keys(data.blockUsage[0].large).map(val => "- " + val + ": " + data.blockUsage[0].large[val]).join("\n")}
`
}

const inputElement = document.getElementById("hohInput");

let html_decode = function(){
	const fileList = inputElement.files;
	readFileAsArrayBuffer(fileList[0], function(data){
		let decodedData = decodeHoh(new Uint8Array(data));
		if(decodedData){
			drawToCanvas(decodedData)
		}
	},function(e){
		console.error(e);
	})
}
inputElement.addEventListener("change",html_decode,false);

const inputElementEncode = document.getElementById("imageInput");
const buttonElementEncode = document.getElementById("encodeButton");

let html_encode = function(){
	if(inputElementEncode.files && inputElementEncode.files[0]){
		let fileName = inputElementEncode.files[0].name;
		let FR = new FileReader();
		FR.onload = function(e){
			let img = new Image();
			img.addEventListener("load", function(){
				let canvas = document.getElementById("preview");
				canvas.height = img.height;
				canvas.width = img.width;
				let ctx = canvas.getContext("2d");
				ctx.drawImage(img, 0, 0);
				let contextData = ctx.getImageData(0,0,img.width,img.height).data;
				let imageData = [];
				for(let i=0;i<img.width;i++){
					let col = [];
					for(let j=0;j<img.height;j++){
						col.push(Math.round(
							contextData[i * 4 + j * img.width * 4]/4
							+ contextData[i * 4 + j * img.width * 4 + 1]/2
							+ contextData[i * 4 + j * img.width * 4 + 2]/4
						))
					};
					imageData.push(col)
				}
				let CBdata = [];
				for(let i=0;i<img.width;i++){
					let col = [];
					for(let j=0;j<img.height;j++){
						col.push(Math.round(
							127.5
							+ contextData[i * 4 + j * img.width * 4]/2
							- contextData[i * 4 + j * img.width * 4 + 2]/2
						))
					};
					CBdata.push(col)
				}
				let CRdata = [];
				for(let i=0;i<img.width;i++){
					let col = [];
					for(let j=0;j<img.height;j++){
						col.push(Math.round(
							127.5
							- contextData[i * 4 + j * img.width * 4]/4
							+ contextData[i * 4 + j * img.width * 4 + 1]/2
							- contextData[i * 4 + j * img.width * 4 + 2]/4
						))
					};
					CRdata.push(col)
				}
				saveByteArray([encodeHoh(imageData,{
					quantizer: (parseFloat(document.getElementById("quantizer").value) || 0),
					forceGradients: document.getElementById("bruteForce").checked,
					lossySmallGradients: true,
					forceGradientsExtra: true,
					useDCT: document.getElementById("useDCT").checked,
					subSampling: (parseFloat(document.getElementById("colourQuantizer").value) || 0)/10,
					maxBlockSize: parseInt(document.getElementById("maxBlockSize").value) || 0,
					edgeWeight: 2.5,
				},CBdata,CRdata)], fileName + ".hoh");
			});
			img.src = e.target.result;
		};       
		FR.readAsDataURL(inputElementEncode.files[0]);
	}
}
inputElementEncode.addEventListener("change",html_encode,false);
buttonElementEncode.addEventListener("click",html_encode,false);

		</script>
	</body>
</html>
